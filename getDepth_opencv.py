import math
import time

import mapper
import numpy as np
import ctypes
import os
import PointCloud
import cv2

from pykinect2 import PyKinectV2
from pykinect2.PyKinectV2 import *
from pykinect2 import PyKinectRuntime
kinect = PyKinectRuntime.PyKinectRuntime(PyKinectV2.FrameSourceTypes_Depth | PyKinectV2.FrameSourceTypes_Color)

intrinsics = [[529.5, 0.0, 365.0],
              [0.0, 529.5, 265.0],
              [0.0, 0.0, 1.0]]

fx = intrinsics[0][0]
fy = intrinsics[1][1] - 200
cx = intrinsics[0][2]
cy = intrinsics[1][2]


depth_frame = kinect.get_last_depth_frame()
depth_img = depth_frame.reshape((kinect.depth_frame_desc.Height, kinect.depth_frame_desc.Width)).astype(np.uint8)
depth_img = cv2.flip(depth_img, 1)


path = 'models/test.ply'
if os.path.exists(path):
    os.remove(path)
f_w = open(path, 'w')
f_w.writelines('ply\nformat ascii 1.0\ncomment generated by: python\nelement vertex 64842\nproperty float x\nproperty float y\nproperty float z\nend_header\n')
count = 0

for i in range(424):
    for j in range(512):
        z = depth_frame[i*512 + j]
        x_over_z = (cx - i) / fx
        y_over_z = (cy - j) / fy
        x = x_over_z * z
        y = y_over_z * z
        if z == 0: continue
        f_w.writelines(str(x)+" "+str(y)+" "+str(z)+'\n')
        count += 1

f_w.close()
f_tr = open(path, 'r')
# f_tw = open(target, 'w')
data = f_tr.readlines()
for i in data[0:]:
    if i.__contains__("element vertex"):
        num = i.split(" ")
        # i = i.replace(num[2], str(count))
        # f_tw.write(i)
        f_tr.close()
        break
file_data = ""
with open(path, "r") as f:
    for line in f:
        line = line.replace(num[2],str(count)+"\n")
        file_data += line
with open(path,"w") as f:
    f.write(file_data)

pcl = PointCloud.Cloud(path)