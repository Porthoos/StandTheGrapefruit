import math
import time

import mapper
import numpy as np
import ctypes
import os
import PointCloud
import cv2

from pykinect2 import PyKinectV2
from pykinect2.PyKinectV2 import *
from pykinect2 import PyKinectRuntime
kinect = PyKinectRuntime.PyKinectRuntime(PyKinectV2.FrameSourceTypes_Depth | PyKinectV2.FrameSourceTypes_Color)

intrinsics = [[529.5, 0.0, 365.0],
              [0.0, 529.5, 265.0],
              [0.0, 0.0, 1.0]]

fx = intrinsics[0][0]
fy = intrinsics[1][1]
cx = intrinsics[0][2]
cy = intrinsics[1][2]

path = 'models/test.ply'

# while True :
    # depth_frame = kinect.get_last_depth_frame()
    # depth_img = depth_frame.reshape((kinect.depth_frame_desc.Height, kinect.depth_frame_desc.Width)).astype(np.uint8)
    # depth_img = cv2.flip(depth_img, 1)
    # max_x = [-1000, -1000, -1000]
    # max_y = [-1000, -1000, -1000]
    # max_z = [-1000, -1000, -1000]
    # min_x = [1000, 1000, 1000]
    # min_y = [1000, 1000, 1000]
    # min_z = [1000, 1000, 1000]
    # for i in range(424):
    #     for j in range(512):
    #         # z = depth_img[i][j]
    #         # x_over_z = (cx - i) / fx
    #         # y_over_z = (cy - j) / fy
    #         point = mapper.depth_point_2_world_point(kinect, _DepthSpacePoint, [i, j])
    #         # print(point)
    #         if point[0] > max_x[0] : max_x = point
    #         if point[1] > max_y[1] : max_y = point
    #         if point[2] > max_z[2] : max_z = point
    #         if point[0] < min_x[0] and point[0] != -math.inf : min_x = point
    #         if point[1] < min_y[1] and point[1] != -math.inf : min_y = point
    #         if point[2] < min_z[2] and point[2] != -math.inf : min_z = point

_world_points = mapper.depth_2_world(kinect, kinect._depth_frame_data, _CameraSpacePoint)
# time.sleep(10)
_world_points = ctypes.cast(_world_points, ctypes.POINTER(ctypes.c_float))
_world_points = np.ctypeslib.as_array(_world_points, shape=(kinect.depth_frame_desc.Height * kinect.depth_frame_desc.Width, 3))
# store points
_dynamic_point_cloud = np.ndarray(shape=(len(_world_points), 3), dtype=np.float32)
_dynamic_point_cloud[:, 0] = _world_points[:, 0] * 1000
_dynamic_point_cloud[:, 1] = _world_points[:, 2] * 1000
_dynamic_point_cloud[:, 2] = _world_points[:, 1] * 1000

max = np.max(_dynamic_point_cloud[:, 1])

if os.path.exists(path):
    os.remove(path)
f_w = open(path, 'w')
f_w.writelines('ply\nformat ascii 1.0\ncomment generated by: python\nelement vertex 64842\nproperty float x\nproperty float y\nproperty float z\nend_header\n')
count = 0
print(max)
for i in _dynamic_point_cloud[1:]:
    # if i[1] >= max - 5:
    #     continue
    if i[0] == -math.inf or i[1] == -math.inf or i[2] == -math.inf: continue
    count += 1
    f_w.writelines(str(i).replace('[','').replace(']','')+'\n')
f_w.close()
f_tr = open(path, 'r')
# f_tw = open(target, 'w')
data = f_tr.readlines()
for i in data[0:]:
    if i.__contains__("element vertex"):
        num = i.split(" ")
        # i = i.replace(num[2], str(count))
        # f_tw.write(i)
        f_tr.close()
        break
file_data = ""
with open(path, "r") as f:
    for line in f:
        line = line.replace(num[2],str(count)+"\n")
        file_data += line
with open(path,"w") as f:
    f.write(file_data)

pcl = PointCloud.Cloud(path)


    # print(max_x)
    # print(max_y)
    # print(max_z)
    # print(min_x)
    # print(min_y)
    # print(min_z)
    # print()



